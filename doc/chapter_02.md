### Глава 2. Проектирование классов с единственной обязанностью
Если класс имеет несколько обязанностей, то:
- его сложно повторно использовать (нельзя получить только нужные части)
- у него больше причин для изменения (соответветственно выше риск нарушить работу зависящего от него кода)  

Класс должен содержать в себе то, что связано с его предназначением  
Не стоит принимать преждевременных проектировочных решений, но можно в коде выразить свои намерения  

Полагаться на поведение а не на данные:  
- скрывать переменные экземпляра (например обернув их в методы доступа)
- скрывать структуры данных (например создавая из них Struct-объекты)  
Повсеместно внедрять единственную обязанность:
- добиваться чтобы каждый метод метод выполнял единственное действие (лучше понять класс, понятнее код, повторное использование, проще вносить изменения)
- изолировать обязанности класса которые к нему не относятся, а затем выносить их в отдельный класс, если новые поступающие изменения уже не относятся к изначальному классу
  
[<=](../readme.md)